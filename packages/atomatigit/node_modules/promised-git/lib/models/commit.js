(function() {
  var Actor, Commit, Diff, Treeish, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('../lodash');

  Actor = require('./actor');

  Diff = require('./diff');

  Treeish = require('./treeish');

  Commit = (function(_super) {
    __extends(Commit, _super);

    function Commit(raw, repo) {
      this.raw = raw;
      this.repo = repo;
      if (!_.isString(raw)) {
        throw new Error('No raw data');
      }
      Commit.__super__.constructor.call(this, this.parseRef(raw), repo);
      this.parseRaw();
    }

    Commit.prototype.parseRaw = function() {
      var _ref, _ref1;
      if (this.ref == null) {
        this.ref = this.parseRef(this.raw);
      }
      this.tree = this.parseTree(this.raw);
      _ref = this.actor(this.parseAuthor(this.raw)), this.author = _ref[0], this.authoredDate = _ref[1];
      _ref1 = this.actor(this.parseCommitter(this.raw)), this.committer = _ref1[0], this.committedDate = _ref1[1];
      this.parents = this.parseParents(this.raw);
      this.gpgsig = this.parseGpgSig(this.raw);
      return this.message = this.parseMessage(this.raw);
    };

    Commit.prototype.parseRef = function(raw) {
      var regex;
      regex = /^(?:commit )?([a-z0-9]{40})$/m;
      return raw.match(regex)[1];
    };

    Commit.prototype.parseTree = function(raw) {
      var regex, _ref;
      regex = /^tree\s(.+)$/m;
      return (_ref = raw.match(regex)) != null ? _ref[1] : void 0;
    };

    Commit.prototype.parseAuthor = function(raw) {
      var regex, _ref;
      regex = /^author\s(.+)$/m;
      return (_ref = raw.match(regex)) != null ? _ref[1] : void 0;
    };

    Commit.prototype.parseCommitter = function(raw) {
      var regex, _ref;
      regex = /^committer\s(.+)$/m;
      return (_ref = raw.match(regex)) != null ? _ref[1] : void 0;
    };

    Commit.prototype.parseParents = function(raw) {
      var parent, parents, regex, _i, _len, _ref, _results;
      regex = /^parent\s(.+)$/gm;
      parents = raw.match(regex) || [];
      _results = [];
      for (_i = 0, _len = parents.length; _i < _len; _i++) {
        parent = parents[_i];
        _results.push((_ref = parent.split(' ')) != null ? _ref[1] : void 0);
      }
      return _results;
    };

    Commit.prototype.parseGpgSig = function(raw) {
      var regex, _ref, _ref1;
      regex = /^[^\-|VERSION|\n](.*)+$/gm;
      return (_ref = raw.match(regex)) != null ? (_ref1 = _ref[1]) != null ? typeof _ref1.join === "function" ? _ref1.join('\n') : void 0 : void 0 : void 0;
    };

    Commit.prototype.parseMessage = function(raw) {
      var message, regex, _ref;
      regex = /^[ ]{4}([^]*)$/gm;
      message = (_ref = raw.match(regex)) != null ? _ref[0] : void 0;
      return message != null ? message.replace(/^ {4}| +$/m, '').trim() : void 0;
    };

    Commit.prototype.actor = function(line) {
      var actor, epoch, m, _ref;
      _ref = (line != null ? line.match(/^(.*?) (\d+) .*$/m) : void 0) || ['', '', ''], m = _ref[0], actor = _ref[1], epoch = _ref[2];
      return [new Actor(actor), new Date(1000 * +epoch)];
    };

    return Commit;

  })(Treeish);

  module.exports = Commit;

}).call(this);
