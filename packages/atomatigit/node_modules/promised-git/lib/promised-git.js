(function() {
  var Amend, Branch, Commit, Diff, File, Promise, PromisedGit, Status, Tag, Treeish, fs, git, path, _, _ref;

  _ = require('./lodash');

  fs = require('fs');

  path = require('path');

  Promise = require('bluebird');

  git = require('./git-wrapper');

  _ref = require('./models'), Amend = _ref.Amend, Branch = _ref.Branch, Commit = _ref.Commit, Diff = _ref.Diff, File = _ref.File, Status = _ref.Status, Tag = _ref.Tag, Treeish = _ref.Treeish;

  PromisedGit = (function() {
    PromisedGit.prototype.Promise = Promise;

    function PromisedGit(cwd) {
      this.cwd = cwd;
      if (!fs.existsSync(cwd)) {
        throw new Error("'" + cwd + "' does not exist!");
      }
    }

    PromisedGit.prototype.add = function(file) {
      if (_.isArray(file)) {
        file = _.map(file, function(val) {
          if (_.isFile(val)) {
            return val.path;
          } else {
            return val;
          }
        });
      } else if (_.isFile(file)) {
        file = file.path;
      } else if (!_.isString(file)) {
        file = '.';
      }
      return this.cmd('add', {
        A: true
      }, file);
    };

    PromisedGit.prototype.amend = function() {
      return this.cmd('log', {
        '1': true,
        format: '%B'
      }).then((function(_this) {
        return function(amendMessage) {
          return new Amend(amendMessage, _this);
        };
      })(this));
    };

    PromisedGit.prototype.branches = function() {
      var branches, commits, _ref1;
      _ref1 = [[], []], commits = _ref1[0], branches = _ref1[1];
      return this.cmd('show-ref', {
        'heads': true
      }).then((function(_this) {
        return function(raw) {
          var oid, rawBranch, rawName, _i, _len, _ref2, _ref3, _ref4;
          _ref3 = ((_ref2 = raw.split('\n')) != null ? _ref2.slice(0, -1) : void 0) || [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            rawBranch = _ref3[_i];
            _ref4 = rawBranch.split(' '), oid = _ref4[0], rawName = _ref4[1];
            commits.push(_this.getCommit(oid));
            branches.push(new Branch(rawName.split('refs/heads/')[1], null));
          }
          return Promise.all(commits);
        };
      })(this)).then(function() {
        var branch, i, _i, _len;
        for (i = _i = 0, _len = branches.length; _i < _len; i = ++_i) {
          branch = branches[i];
          branch.commit = commits[i].value();
        }
        return branches;
      });
    };

    PromisedGit.prototype.checkout = function(oid, options) {
      var _ref1;
      if (oid == null) {
        oid = 'HEAD';
      }
      if (options == null) {
        options = {};
      }
      if (_.isPlainObject(oid)) {
        _ref1 = [oid, 'HEAD'], options = _ref1[0], oid = _ref1[1];
      }
      return this.cmd('checkout', options, oid);
    };

    PromisedGit.prototype.checkoutFile = function(file, oid) {
      var options;
      if (oid == null) {
        oid = 'HEAD';
      }
      options = {
        f: true,
        treeish: oid
      };
      if (_.isArray(file)) {
        file = _.map(file, function(val) {
          if (_.isFile(val)) {
            return val.path;
          } else {
            return val;
          }
        });
      } else if (_.isFile(file)) {
        file = file.path;
      } else if (!_.isString(file)) {
        return Promise.reject(new Error("Invalid file: '" + file + "'"));
      }
      return this.cmd('checkout', options, file);
    };

    PromisedGit.prototype.cmd = function(command, options, args) {
      var _ref1;
      if (_.isArray(options) || _.isString(options)) {
        _ref1 = [null, options], options = _ref1[0], args = _ref1[1];
      }
      if (options == null) {
        options = {};
      }
      if (args == null) {
        args = [];
      }
      return git(command, options, args, this.cwd);
    };

    PromisedGit.prototype.commit = function(message, options) {
      if (options == null) {
        options = {};
      }
      if (!_.isString(message)) {
        return Promise.reject(new Error('No commit message!'));
      }
      if (!_.has(options, 'cleanup')) {
        options.cleanup = 'strip';
      }
      if (fs.existsSync(message)) {
        options.file = message;
      } else {
        options.m = message;
      }
      return this.cmd('commit', options);
    };

    PromisedGit.prototype.getCommit = function(oid, options) {
      if (options == null) {
        options = {};
      }
      if (!_.isString(oid)) {
        Promise.reject(new Error('Invalid oid'));
      }
      _.extend(options, {
        'pretty': 'raw'
      });
      return this.show(oid, null, options).then((function(_this) {
        return function(raw) {
          return new Commit(raw, _this);
        };
      })(this));
    };

    PromisedGit.prototype.getDiff = function(file, options) {
      var diffs, filePath, _ref1;
      if (options == null) {
        options = {};
      }
      if (_.isPlainObject(file)) {
        _ref1 = [file, null], options = _ref1[0], file = _ref1[1];
      }
      if (!(_.has(options, 'treeish') || (file != null))) {
        return this.status().then((function(_this) {
          return function(o) {
            var paths;
            paths = 'cached' in options ? _.map(o.staged, 'path') : _.map(o.unstaged, 'path');
            return _this.getDiff(paths, options);
          };
        })(this));
      } else if (_.isArray(file)) {
        diffs = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = file.length; _i < _len; _i++) {
            filePath = file[_i];
            _results.push(this.getDiff(filePath, options).then(function(diff) {
              return diff;
            })["catch"](function() {
              return null;
            }));
          }
          return _results;
        }).call(this);
        return Promise.all(diffs).then(_.compact);
      } else {
        _.extend(options, {
          'p': true,
          'unified': 1,
          'no-color': true
        });
        return this.cmd('diff', options, file).then(function(raw) {
          if (!(raw != null ? raw.length : void 0) > 0) {
            throw new Error("'" + file + "' has no diffs! Forgot '--cached'?");
          }
          return new Diff(file, raw);
        });
      }
    };

    PromisedGit.prototype.getTags = function(maxCount) {
      var options;
      if (maxCount == null) {
        maxCount = 15;
      }
      options = {
        format: '%(objectname) %(refname)',
        sort: 'authordate',
        count: maxCount
      };
      return this.cmd('for-each-ref', options, 'refs/tags/').then((function(_this) {
        return function(raw) {
          var tags;
          if (!(raw != null ? raw.length : void 0) > 0) {
            throw new Error('No tags available');
          }
          tags = raw.split('\n').slice(0, -1);
          return Promise.map(tags, function(tagRaw) {
            return new Tag(tagRaw, _this);
          });
        };
      })(this));
    };

    PromisedGit.prototype.init = function() {
      return this.cmd('init');
    };

    PromisedGit.prototype.log = function(ref, limit) {
      var options, _ref1;
      if (ref == null) {
        ref = 'HEAD';
      }
      if (limit == null) {
        limit = 15;
      }
      if (_.isNumber(ref)) {
        _ref1 = ['HEAD', ref], ref = _ref1[0], limit = _ref1[1];
      }
      options = {
        'header': true,
        'max-count': limit
      };
      return this.cmd('rev-list', options, ref).then((function(_this) {
        return function(commitsRaw) {
          var raw, _i, _len, _ref2, _results;
          commitsRaw = ((_ref2 = commitsRaw.split('\0')) != null ? _ref2.slice(0, -1) : void 0) || [];
          _results = [];
          for (_i = 0, _len = commitsRaw.length; _i < _len; _i++) {
            raw = commitsRaw[_i];
            _results.push(new Commit(raw, _this));
          }
          return _results;
        };
      })(this));
    };

    PromisedGit.prototype.refreshIndex = function() {
      var options;
      options = {
        refresh: true
      };
      return this.cmd('add', options, '.');
    };

    PromisedGit.prototype.remoteBranches = function() {
      var branches, commits, _ref1;
      _ref1 = [[], []], commits = _ref1[0], branches = _ref1[1];
      return this.cmd('for-each-ref', 'refs/remotes').then((function(_this) {
        return function(raw) {
          var oid, rawBranch, rawName, _i, _len, _ref2, _ref3, _ref4;
          _ref3 = (raw != null ? typeof raw.split === "function" ? (_ref2 = raw.split('\n')) != null ? _ref2.slice(0, -1) : void 0 : void 0 : void 0) || [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            rawBranch = _ref3[_i];
            _ref4 = rawBranch != null ? rawBranch.split('commit') : void 0, oid = _ref4[0], rawName = _ref4[1];
            commits.push(_this.getCommit(oid.trim()));
            branches.push(new Branch(rawName != null ? rawName.trim().split('refs/remotes/')[1] : void 0, null));
          }
          return Promise.all(commits);
        };
      })(this)).then(function() {
        var branch, i, _i, _len;
        for (i = _i = 0, _len = branches.length; _i < _len; i = ++_i) {
          branch = branches[i];
          branch.commit = commits[i].value();
        }
        return branches;
      });
    };

    PromisedGit.prototype.reset = function(oid, options) {
      var _ref1;
      if (oid == null) {
        oid = 'HEAD';
      }
      if (options == null) {
        options = {};
      }
      if (_.isTreeish(oid)) {
        oid = oid.ref;
      } else if (_.isPlainObject(oid)) {
        _ref1 = [oid, 'HEAD'], options = _ref1[0], oid = _ref1[1];
      }
      return this.cmd('reset', options, oid);
    };

    PromisedGit.prototype.revParse = function(oid, options) {
      var _ref1;
      if (oid == null) {
        oid = 'HEAD';
      }
      if (options == null) {
        options = {};
      }
      if (_.isTreeish(oid)) {
        oid = oid.ref;
      } else if (_.isPlainObject(oid)) {
        _ref1 = [oid, 'HEAD'], options = _ref1[0], oid = _ref1[1];
      } else if (!_.isString(oid)) {
        return Promise.reject(new Error('Invalid oid'));
      }
      return this.cmd('rev-parse', options, oid);
    };

    PromisedGit.prototype.show = function(oid, file, options) {
      var isTreeishAnExistingPath, _ref1, _ref2, _ref3, _ref4, _ref5;
      if (_.isTreeish(file)) {
        _ref1 = [file, oid], oid = _ref1[0], file = _ref1[1];
      } else if (_.isFile(oid)) {
        _ref2 = [file, oid], oid = _ref2[0], file = _ref2[1];
      }
      if (_.isPlainObject(file)) {
        _ref3 = [file, null], options = _ref3[0], file = _ref3[1];
      } else if (_.isPlainObject(oid)) {
        _ref4 = [oid, null], options = _ref4[0], oid = _ref4[1];
      }
      if ((file == null) && _.isString(oid)) {
        isTreeishAnExistingPath = fs.existsSync(path.join(this.cwd, oid));
        if (isTreeishAnExistingPath) {
          _ref5 = [file, oid], oid = _ref5[0], file = _ref5[1];
        }
      }
      if (_.isTreeish(oid)) {
        oid = oid.ref;
      } else if (!_.isString(oid)) {
        oid = '';
      }
      if (_.isFile(file)) {
        file = file.path;
      } else if (!_.isString(file)) {
        file = '';
      }
      if (file.length !== 0 && oid.length !== 0) {
        file = ":" + file;
      }
      return this.cmd('show', options, "" + oid + file);
    };

    PromisedGit.prototype.status = function() {
      var options;
      options = {
        z: true,
        b: true
      };
      return this.cmd('status', options).then((function(_this) {
        return function(raw) {
          return new Status(raw, _this);
        };
      })(this));
    };

    PromisedGit.prototype.unstage = function(file) {
      if (_.isArray(file)) {
        file = _.map(file, function(val) {
          if (_.isFile(val)) {
            return val.path;
          } else {
            return val;
          }
        });
      } else if (_.isFile(file)) {
        file = file.path;
      } else if (!_.isString(file)) {
        file = '.';
      }
      return this.cmd('reset', {
        treeish: 'HEAD'
      }, file);
    };

    return PromisedGit;

  })();

  module.exports = PromisedGit;

}).call(this);
